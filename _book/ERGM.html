<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Section 8 Exponential Random Graph Models | Online Companion to Archaeological Network Science</title>
<meta name="author" content="Matthew A. Peeples and Tom Brughmans">
<meta name="description" content="Exponential Random Graph Models (ERGM; typically pronounced “UR-gum”) are a class of statistical models designed to help represent, evaluate, and simulate ideas about network generating processes...">
<meta name="generator" content="bookdown 0.26 with bs4_book()">
<meta property="og:title" content="Section 8 Exponential Random Graph Models | Online Companion to Archaeological Network Science">
<meta property="og:type" content="book">
<meta property="og:url" content="https://book.archnetworks.net/ERGM.html">
<meta property="og:image" content="https://book.archnetworks.net/images/cover.png">
<meta property="og:description" content="Exponential Random Graph Models (ERGM; typically pronounced “UR-gum”) are a class of statistical models designed to help represent, evaluate, and simulate ideas about network generating processes...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Section 8 Exponential Random Graph Models | Online Companion to Archaeological Network Science">
<meta name="twitter:description" content="Exponential Random Graph Models (ERGM; typically pronounced “UR-gum”) are a class of statistical models designed to help represent, evaluate, and simulate ideas about network generating processes...">
<meta name="twitter:image" content="https://book.archnetworks.net/images/cover.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/_Lato-0.4.1/font.css" rel="stylesheet">
<link href="libs/_Roboto%20Mono-0.4.1/font.css" rel="stylesheet">
<link href="libs/_Montserrat-0.4.1/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.3.1/transition.js"></script><script src="libs/bs3compat-0.3.1/tabs.js"></script><script src="libs/bs3compat-0.3.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/htmlwidgets-1.5.4/htmlwidgets.js"></script><link href="libs/vis-9.1.0/vis-network.min.css" rel="stylesheet">
<script src="libs/vis-9.1.0/vis-network.min.js"></script><script src="libs/visNetwork-binding-2.1.0/visNetwork.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script type="text/javascript" src="https://www.mattpeeples.net/book/particles.min.js"></script><script type="text/javascript" src="https://www.mattpeeples.net/book/custom.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-MHX9HQF2BQ"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-MHX9HQF2BQ');
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
<link rel="stylesheet" href="style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Online Companion to <em>Archaeological Network Science</em></a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents:</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Welcome</a></li>
<li class="book-part">PART I: Getting Started</li>
<li><a class="" href="GettingStarted.html"><span class="header-section-number">1</span> Getting Started with R</a></li>
<li class="book-part">PART II: Work While You Read</li>
<li><a class="" href="DataAndWorkspace.html"><span class="header-section-number">2</span> Data and Workspace Setup</a></li>
<li><a class="" href="NetworkData.html"><span class="header-section-number">3</span> Network Data in R</a></li>
<li><a class="" href="Exploratory.html"><span class="header-section-number">4</span> Exploratory Network Analysis</a></li>
<li><a class="" href="Uncertainty.html"><span class="header-section-number">5</span> Quantifying Uncertainty</a></li>
<li><a class="" href="Visualization.html"><span class="header-section-number">6</span> Network Visualization</a></li>
<li><a class="" href="SpatialNetworks.html"><span class="header-section-number">7</span> Spatial Networks</a></li>
<li class="book-part">PART III: Going Beyond the Book</li>
<li><a class="active" href="ERGM.html"><span class="header-section-number">8</span> Exponential Random Graph Models</a></li>
<li><a class="" href="SpatialInteraction.html"><span class="header-section-number">9</span> Spatial Interaction Models</a></li>
<li><a class="" href="Affiliation.html"><span class="header-section-number">10</span> Affiliation Data and Co-Association</a></li>
<li class="book-part">Additional Material</li>
<li><a class="" href="TableOfContents.html">Table of Contents Quick Reference</a></li>
<li><a class="" href="references-and-r-packages.html">References and R Packages</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/mpeeples2008/ArchNetSci">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><iframe src="https://mattpeeples.net/book/index.html" style="border:0px #ffffff none;" name="header_frame" scrolling="no" frameborder="0" marginheight="0px" marginwidth="0px" height="100px" width="100%" allowfullscreen></iframe>
<div id="ERGM" class="section level1" number="8">
<h1>
<span class="header-section-number">Section 8</span> Exponential Random Graph Models<a class="anchor" aria-label="anchor" href="#ERGM"><i class="fas fa-link"></i></a>
</h1>
<p>Exponential Random Graph Models (ERGM; typically pronounced “UR-gum”) are a class of statistical models designed to help represent, evaluate, and simulate ideas about network generating processes and structural properties (for a good introductions to the method see Lusher et al. 2013; and for archaeological cases see Amati et al. 2020; Brughmans et al. 2014; Wang and Marwick 2021). These models allow us to formally represent our theories about how particular patterns of relationships (such as paths of a given length or triads of a specific configuration) or associations (such as mutuality or connections among nodes that share an attribute) emerge and persist in our networks. Further ERGMs help us evaluate how well such theories account for our observed network data. Specifically, an ERGM can be used to generate large numbers of networks in a random process targeted towards particular configurations and associations that represent our theories of interest. We can then compare those simulated networks to our observed network to generate perspectives on the plausibility of our theory. Essentially, ERGMs help us determine how the local tendencies in network formation generate the global properties and structures of our networks.</p>
<p>In many ways, ERGMs are similar to logistic regression models where we predict the presence or absence of ties between pairs of nodes with edge formation modeled as dependent on network structure and properties (e.g., density, transitivity, centralization, etc.). Such models help us assess the probability that the observed network is a product of specified properties or generative processes that may be more or less likely to occur than we would expect by chance in a random network.</p>
<p>The details of ERGMs and the underlying mathematics are beyond the scope of this document, but we present a brief overview of the highlights based heavily on <a href="http://statnet.org/Workshops/ergm_tutorial.html">a workshop on ERGM by the <code>statnet</code> team</a> (Krivitsky et al. 2021). See that workshop for more details.</p>
<p>The general model form for an ERGM can be written as:</p>
<p><span class="math display">\[P(Y=y) = \frac{\text{exp}(\theta' g(y))}{k(\theta)}\]</span></p>
<p>where</p>
<ul>
<li>
<span class="math inline">\(P(Y=y)\)</span> is the probability that the network will take a given state <span class="math inline">\(y\)</span> among random possibilities <span class="math inline">\(Y\)</span>.</li>
<li>
<span class="math inline">\(g(y)\)</span> is the set of model ERGM terms considered. These are essential the covariates in the model.</li>
<li>
<span class="math inline">\(\theta\)</span> is the set of coefficients for model terms.</li>
<li>
<span class="math inline">\(k(\theta)\)</span> is a normalizing constant defined as numerator summed overall all possible networks constrained on the node set <span class="math inline">\(y\)</span>. In other words, all possible network configurations that could exist with the given node set.</li>
</ul>
<p>The general form for an ERGM expressed in terms of the entire network as we see above can also be expressed in terms of the conditional log odds of an edge existing between any two nodes as follows:</p>
<p><span class="math display">\[\text{logit}(Y_{ij}=y_{ij}) = \theta'\delta(y_{ij})\]</span></p>
<p>where</p>
<ul>
<li>
<span class="math inline">\(Y_{ij}\)</span> is the random variable for the state of the edge (present or absent) for a given pair of nodes <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> and <span class="math inline">\(y_{ij}\)</span> is the observed state.</li>
<li>
<span class="math inline">\(\delta (y_{ij})\)</span> is the change statistic representing how <span class="math inline">\(g(y)\)</span> (the state of the graph and associated terms) changes if the edge between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> is active or not.</li>
<li>
<span class="math inline">\(\theta\)</span> describes the contribution of a term to the log odds of an individual edge between <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> conditioned on the state of all other edges remaining the same (we explain this in more detail below with examples).</li>
</ul>
<p>The coefficient estimates in ERGM models are returned in log odds which indicates the change in the likelihood of an edge per unit change in the given predictor (this is where the “change statistic”) comes in. For example a coefficient estimate <span class="math inline">\(\theta\)</span> of 1.5 for a given term would indicate that the likelihood of an edge is 1.5 times higher for every change of that term by 1 unit. Conversely, an coefficient estimate for a term of -5.5 would suggest that the likelihood of an edge is 5.5 times <em>less</em> likely for every unit change of the term. In general, positive coefficients suggest that a given network feature denoted by the term is more common than we would expect by chance and a negative value suggests it is less common than we would expect by chance (given the constraints placed on network construction). The magnitude of the coefficients further provides an indication of how much more or fewer of a given features we see than we would expect. We explain how this works in more detail in the examples below.</p>
<div class="rmdtip">
<p>
The log odds is the logarithm of the odds ratio. The odds ratio
refers to the probability that an event occurs divided by the
probability that an event does not occur (1 minus the probability that
it occurs). This can be written formally as:
</p>
<p>
<span class="math inline"><span class="math inline">\(\text{log}(A) = \frac{\text{log}(P(A)}{(1-P(A))}\)</span></span>
</p>
<p>
where
</p>
<ul>
<li>
<span class="math inline"><span class="math inline">\(\text{log}(A)\)</span></span> is the log odds
of event A
</li>
<li>
<span class="math inline"><span class="math inline">\(\text{log}(P(A)\)</span></span> is the
probability of event A occurring
</li>
<li>
<span class="math inline"><span class="math inline">\(\text{log}(1-(P(A))\)</span></span> is the
probability of event A not occurring
</li>
</ul>
<p>
Negative log odds values indicate that probability of an event
occurring is &lt; 0.5 and positive log odds values indicate that the
probability of an event occurring is &gt; 0.5. Log odds will be exactly
0 when the probability of an event occurring is 0.5.
</p>
</div>
<div id="ERGMsInR" class="section level2" number="8.1">
<h2>
<span class="header-section-number">8.1</span> ERGMs in R<a class="anchor" aria-label="anchor" href="#ERGMsInR"><i class="fas fa-link"></i></a>
</h2>
<p>In general, the analysis of ERGMs in R is conducted in three basic steps:</p>
<ul>
<li>First, we asses the general properties of interest in our network using exploratory network statistics described <a href="Exploratory.html#Exploratory">in the Exploratory Network Analysis section of this document</a>.</li>
<li>Next, we define our network terms of interest and fit one or more ERGMs to our observed network and assess the results.</li>
<li>Finally, we assess the goodness of fit of our models and assess the diagnostic statistics for our model generating processes.</li>
</ul>
<p>If all goes well in the steps above, we can then evaluate our network theory or property of interest in relation to the ERGM that we created.</p>
<div class="rmdnote">
<p>
The <code>statnet</code> suite of packages includes a package called
<code>ergm</code> that facilitates the analysis of ERGMs in R and an
additional package called <code>tergm</code> that provides terms and
methods for analyzing temporal networks using ERGMs. Networks need to be
in the <code>network</code> format to be analysed using the
<code>statnet</code> suite of packages.
</p>
</div>
<p>Let’s initialize our <code>statnet</code> suite to get started:</p>
<div class="sourceCode" id="cb559"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="http://statnet.org">statnet</a></span><span class="op">)</span> <span class="co"># initialize statnet library</span></code></pre></div>
<p>In many ways it is easiest to describe what ERGMs do and how they work by example. In the next sections we provide a couple of archaeological examples that highlight some of the ways ERGMs have or could be used in archaeology. We further provide additional resources for taking these methods further.</p>
</div>
<div id="CranborneChase" class="section level2" number="8.2">
<h2>
<span class="header-section-number">8.2</span> Cranborne Chase Visibility Network Example<a class="anchor" aria-label="anchor" href="#CranborneChase"><i class="fas fa-link"></i></a>
</h2>
<p>We start with an example that was described briefly in the Brughmans and Peeples (2022) book in Chapter 4, but not covered in detail. Specifically, we explore the potential generative processes involved in the development of the intervisibility network among long barrows in the Cranborne Chase area in southern England. As this example is only briefly described in the Brughmans and Peeples (2022) book, you may also want to read and follow along with the original article where that analyses first appeared (<a href="https://www.frontiersin.org/articles/10.3389/fdigh.2017.00017/">Brughmans and Brandes 2017</a>).</p>
<p>Briefly, the network consists of a set of nodes which represent long barrows and edges among them which represent ground-truthed ties of intervisbility between pairs of barrows. The original data came from work by Chris Tilley (1994). These data were used by Brughmans and Brandes (2017) to formally test the notion put forth by Tilley that highly visible barrows “attracted” others over time. In network terms this could be characterized as a “preferential attachment” process. Brughmans and Brandes created an ERGM model with particular properties drawn from Tilley’s theoretical model of network development and found that networks simulated with those properties using ERGMs had substantially similar properties to the observed network. Based on this, they considered Tilley’s theoretical model plausible.</p>
<div class="figure">
<img src="images/long_barrow.jpg" style="width:100.0%" alt=""><p class="caption">Photograph of a long barrow at Cranborne Chase. <a href="https://commons.wikimedia.org/wiki/File:Gussage_down_long_barrow.jpg">Original image by Jim Champion: CC 3.0</a></p>
</div>
<p>The original ERGM analysis published by Brughmans and Brandes was conducted in a Java program designed for ERGM analysis called <a href="http://www.melnet.org.au/pnet">PNet</a>. Here we replicate some of their results and a few additional analyses using slightly different methods and assumptions in R by way of demonstration. Our results differ slightly from the published results because of the randomness inherent in fitting ERGMs but all coefficient retain the same sign and magnitude suggesting a good replication of the most important results.</p>
<div id="NetProperties" class="section level3" number="8.2.1">
<h3>
<span class="header-section-number">8.2.1</span> Assessments of Network Properties<a class="anchor" aria-label="anchor" href="#NetProperties"><i class="fas fa-link"></i></a>
</h3>
<p>Let’s start by bringing in our Cranborne Chase network data (as a <code>network</code> object) and looking at the general properties of the network object.</p>
<div class="sourceCode" id="cb560"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/load.html">load</a></span><span class="op">(</span><span class="st">"data/cranborne.Rdata"</span><span class="op">)</span>
<span class="va">cranborne</span></code></pre></div>
<pre><code>##  Network attributes:
##   vertices = 32 
##   directed = FALSE 
##   hyper = FALSE 
##   loops = FALSE 
##   multiple = FALSE 
##   bipartite = FALSE 
##   total edges= 49 
##     missing edges= 0 
##     non-missing edges= 49 
## 
##  Vertex attribute names: 
##     vertex.names 
## 
## No edge attributes</code></pre>
<p>This network is an undirected, unweighted network object with 32 nodes and 46 edges. Let’s look at a few properties of the network including density, mean degree, degree centralization, and number of isolates.</p>
<div class="sourceCode" id="cb562"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">sna</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sna/man/gden.html">gden</a></span><span class="op">(</span><span class="va">cranborne</span><span class="op">)</span> <span class="co"># density</span></code></pre></div>
<pre><code>## [1] 0.09879032</code></pre>
<div class="sourceCode" id="cb564"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="fu">sna</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sna/man/degree.html">degree</a></span><span class="op">(</span><span class="va">cranborne</span><span class="op">)</span><span class="op">)</span> <span class="co"># mean degree</span></code></pre></div>
<pre><code>## [1] 6.125</code></pre>
<div class="sourceCode" id="cb566"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">sna</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sna/man/centralization.html">centralization</a></span><span class="op">(</span><span class="va">cranborne</span>, g <span class="op">=</span> <span class="fl">1</span>, <span class="va">degree</span><span class="op">)</span> <span class="co"># degree centralization</span></code></pre></div>
<pre><code>## [1] 0.2043011</code></pre>
<div class="sourceCode" id="cb568"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="fu">sna</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sna/man/isolates.html">isolates</a></span><span class="op">(</span><span class="va">cranborne</span><span class="op">)</span><span class="op">)</span> <span class="co"># numbe of isolates</span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<p>This is a fairly sparse network with few isolates and a low degree centralization.</p>
<p>Let’s plot it with nodes scaled by degree:</p>
<div class="sourceCode" id="cb570"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">4367</span><span class="op">)</span>
<span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">cranborne</span>, vertex.cex <span class="op">=</span> <span class="op">(</span><span class="fu">sna</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sna/man/degree.html">degree</a></span><span class="op">(</span><span class="va">cranborne</span><span class="op">)</span> <span class="op">/</span> <span class="fl">4</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="07-ergm_files/figure-html/unnamed-chunk-6-1.png" width="672"></div>
<p>This network has 3 components and a few isolates. In general many of the nodes have similar degree centrality values but there are a few nodes which appear to have higher degree. We can look at a histogram of degree centrality to further assess the distribution.</p>
<div class="sourceCode" id="cb571"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/hist.html">hist</a></span><span class="op">(</span><span class="fu">sna</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sna/man/degree.html">degree</a></span><span class="op">(</span><span class="va">cranborne</span><span class="op">)</span>,
     breaks <span class="op">=</span> <span class="fl">10</span>,
     main <span class="op">=</span> <span class="st">"Degree Distribution"</span>,
     xlab <span class="op">=</span> <span class="st">"Degree Centrality"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="07-ergm_files/figure-html/unnamed-chunk-7-1.png" width="672"></div>
</div>
<div id="fitting-models-with-ergm" class="section level3" number="8.2.2">
<h3>
<span class="header-section-number">8.2.2</span> Fitting Models with <code id="FitModels">ergm</code><a class="anchor" aria-label="anchor" href="#fitting-models-with-ergm"><i class="fas fa-link"></i></a>
</h3>
<p>Now that we’ve explored some of the basic properties of our network, the next step is to begin to fit ERGMs to our observed network. The first thing we are going to do is fit a very simple model with only one term. In the <code>ergm</code> package “terms” refer to the specific constraints placed on our randomly generated networks (see <code><a href="https://rdrr.io/pkg/tergm/man/ergm-terms.html">?ergm.terms</a></code> for a list of the many built-in terms). The most basic term that is included in many models is <code>edges</code> which simply refers to the number of edges in a network. An ERGM with a single <code>edges</code> term is conceptually equivalent to a typical GLM regression model where the only predictor is the intercept.</p>
<p>In the chunk of code below we see the form that <code>ergm</code> model objects take in R. Inside the <code>ergm</code> call we have our network on the left hand size <code>cranborne</code> followed by <code>~</code> and then followed by <code>edges</code> which is a built-in “term” in the <code>ergm</code> package. As we will see below, when we use multiple terms we separate them by a <code>+</code>. Once we have crated our <code>ergm</code> model object we then explore the output using the <code><a href="https://rdrr.io/r/base/summary.html">summary()</a></code> function.</p>
<div class="sourceCode" id="cb572"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mod_null</span> <span class="op">&lt;-</span> <span class="fu">ergm</span><span class="op">(</span><span class="va">cranborne</span> <span class="op">~</span> <span class="va">edges</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">mod_null</span><span class="op">)</span></code></pre></div>
<pre><code>## Call:
## ergm(formula = cranborne ~ edges)
## 
## Maximum Likelihood Results:
## 
##       Estimate Std. Error MCMC % z value Pr(&gt;|z|)    
## edges  -2.2107     0.1505      0  -14.69   &lt;1e-04 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
##      Null Deviance: 687.6  on 496  degrees of freedom
##  Residual Deviance: 319.8  on 495  degrees of freedom
##  
## AIC: 321.8  BIC: 326  (Smaller is better. MC Std. Err. = 0)</code></pre>
<p>In the output above there are a number of important features that need explanation.</p>
<p>The summary output includes the call/model formula we used followed by the Maximum Likelihood Results. The output we will focus on here includes the estimates of each model term, the standard error of the estimates, and the p-value associated with that term:</p>
<ul>
<li>First, in the example here, we get an estimate of <code>edges</code> as <code>-2.2107</code> which is the conditional log odds of two nodes having an edge between them (explained further below)</li>
<li>Next, we have the standard error of the coefficient estimate.</li>
<li>And we also have “Pr(&gt;|z|) which is the p-value associated with a particular term. The p-value here is calculated as a function of the relative size of the coefficient estimate and the standard error.</li>
</ul>
<p>What the estimate (and associated standard error and p-value) indicates is how much a change in the term by one unit changes the likelihood that a particular edge is present. In this case, a change by one unit in the term <code>edges</code> refers to the addition of exactly 1 edge to the network (<span class="math inline">\(\delta(g(y)) = 1\)</span>) so the coefficient is an estimate of how much the addition of 1 edge to the network changes the likelihood of any particular edge:</p>
<p><span class="math display">\[\begin{aligned}
\text{logit}(p(y)) &amp; = \theta \times \delta(g(y))\\
&amp; = -2.2107 \times \text{change in the number of edges}\\
&amp; = -2.2107 \times 1\\
&amp; = -2.2107
\end{aligned}\]</span></p>
<p>So in this example, the likelihood of an edge between two particular nodes is <code>2.2107</code> times <em>less</em> likely for every additional increase in the number of network by 1 edge in the network as a whole. So for every edge added the probability that a particular edge is present decreases. What this negative coefficient means is that an edge is more likely absent than present (and a positive coefficient would suggest the opposite) and thus, if we add an edge elsewhere in the network it is even less likely that our target edge will be active. We can calculate the probability of that an edge is present by taking the inverse logit of <span class="math inline">\(\theta\)</span>:</p>
<div class="sourceCode" id="cb574"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2.2107</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2.2107</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 0.09879373</code></pre>
<p>As we would expect, this number is very close to the density of the network which is what the <code>edges</code> term uses as a constraint (number of edges is a function of density):</p>
<div class="sourceCode" id="cb576"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">sna</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sna/man/gden.html">gden</a></span><span class="op">(</span><span class="va">cranborne</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 0.09879032</code></pre>
<p>What this indicates is that if we are trying to predict a given network state (a given set of present an absent edges) and the only information we know is the network density, the probability that a particular edge is present is roughly equal to the network density. As the coefficient is statistically significant, this means that there is a low probability (p-value) of obtaining a model with no terms at random that provides as good or better predictions of the observed than the model including the <code>edges</code> term.</p>
<p>Finally we can see our model fit statistics at the bottom with <a href="https://en.wikipedia.org/wiki/Akaike_information_criterion">AIC (Akaike Information Criterion)</a> and <a href="https://en.wikipedia.org/wiki/Bayesian_information_criterion">BIC (Bayesian Information Criterion)</a>. These are both model fit statistics that can be used to compare competing models where lower values represent better fit between the model and the data. Further, the Null deviance is a measure of how well the network was predicted by a model with no covariates vs. the residual deviance which is a measure of how well the network is predicted by a model with the covariates. Residual deviance will be lower than Null deviance and bigger gap between the two is better. In general, the absolute values of these model fit terms do not matter but rather they provide a means for comparing multiple models for predicting the same observations as we will see below.</p>
</div>
<div id="ModelTheory" class="section level3" number="8.2.3">
<h3>
<span class="header-section-number">8.2.3</span> Building a Model Based on Theory<a class="anchor" aria-label="anchor" href="#ModelTheory"><i class="fas fa-link"></i></a>
</h3>
<p>The simple example above built an ERGM predicated on nothing but network density using the <code>edges</code> term. As outlined by Brughmans and Brandes (2017) there are specific features of the Cranborne Chase network development process theorized by Tilley which could be converted into a formal ERGM model using specific <code>ergm.terms</code>. Specifically, Tilley suggested that long barrows tended to be clustered into groups and intervisibility was a primary concern for some, but not all long barrows. Further, he suggested that long barrows tended to be clustered in sets and include straight paths where multiple barrows were visible from a single point. Finally, Tilley suggested that barrows that were already highly visible tended to attract new visibility connections through time. To capture this theory of network development in formal terms, Brughmans and Brandes (2017) create a set of terms to match Tilley’s expectations. They include the following terms:</p>
<ul>
<li>
<strong><code>edges</code></strong> - the number of active edges: this term represents the tendency for long barrows to have visibility connections.</li>
<li>
<strong><code>triangle</code></strong> - the number of closed triangles: this term represents the clustering that Tilley expects in the network as networks with many closed triangles often have distinct clusters.</li>
<li>
<strong><code>threetrail</code></strong> - the number of paths or trails of 3 (<code>threepath</code> and <code>threetrail</code> are used equivalently in the <code>ergm</code> here) in the network: this term is meant to capture Tilley’s visual pathways where multiple barrows are visible in a specific direction.</li>
<li>
<strong><code>altkstar</code></strong> - alternating stars: this term is used to represent certain nodes with high degree distribution representing the prominent nodes in the network generated through a process of preferential attachment.</li>
<li>
<strong><code>isolates</code></strong> - the number of isolates in the network: this term is here to capture the tendency for nodes to not be isolate as Tilley describes.</li>
</ul>
<p>Here are visual representations of these network configurations from Brughmans and Brandes (2017):</p>
<div class="figure">
<img src="images/BrughmansBrandes.jpg" style="width:60.0%" alt=""><p class="caption">Network terms included in ERGM</p>
</div>
<p>Brughmans and Brandes present two versions of the model in the article. The first excludes the <code>isolates</code> term and the second includes it. Let’s replicate their results here. Note that we are using different software and terms may be defined slightly differently so our results may differ a bit from their published results. Further, ERGMs include random simulation to two runs of the same model will not return the same results unless we supply a random seed. To do that in the <code>ergm</code> call we use a <code>control</code> argument as we see below.</p>
<p>Let’s first go over what it is to be included in the terms. We want to first create a model with the terms <code>edges</code>, <code>triangle</code>, <code>threetrail</code>, and <code>altkstar</code>. Most of the terms can be used without further arguments but the <code>altkstar</code> term needs an additional weight parameter <code>lambda</code> and for us to define that weight parameter as fixed (see <a href="https://zalmquist.github.io/ERGM_Lab/ergm-terms.html#:~:text=ergm%20functions%20such%20as%20ergm,valued%20mode%20and%20vice%20versa.">term descriptions here</a> for more details).</p>
<div class="rmdwarning">
<p>
ERGMs can sometimes take quite a bit of time to run as they involve
generating lots of estimates of random variables using the MCMC process.
In order to control the behavior of the MCMC sampling process, we can
use the <code>control</code> argument within the <code>ergm</code>
function. In the examples here we have opted for a fairly large sample
size per chain and a relatively large interval between samples. As we
will see further below, this will help with our coefficient estimates
and model fit but the trade off is time. If you want to simply run the
models in the examples below quickly, you simply remove these three
arguements within the <code>control.ergm</code> function call:
<code>MCMC.burnin</code>, <code>MCMC.interval</code>, and
<code>MCMC.samplesize</code>.
</p>
</div>
<p>Let’s fit the model and look at the summary. Note when you run this on your own computer you will see additional verbose output on the console as the sampling process proceeds. We have eliminated that here to avoid visual clutter:</p>
<div class="sourceCode" id="cb578"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mod1</span> <span class="op">&lt;-</span> <span class="fu">ergm</span><span class="op">(</span>
  <span class="va">cranborne</span> <span class="op">~</span> <span class="va">edges</span> <span class="op">+</span> <span class="va">triangle</span> <span class="op">+</span> <span class="va">threetrail</span> <span class="op">+</span>
    <span class="fu">altkstar</span><span class="op">(</span>lambda <span class="op">=</span> <span class="fl">2</span>, fixed <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,
  control <span class="op">=</span> <span class="fu">control.ergm</span><span class="op">(</span>
    MCMC.burnin <span class="op">=</span> <span class="fl">1000</span>,
    MCMC.interval <span class="op">=</span> <span class="fl">15000</span>,
    MCMC.samplesize <span class="op">=</span> <span class="fl">25000</span>,
    seed <span class="op">=</span> <span class="fl">34526</span>
  <span class="op">)</span>
<span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">mod1</span><span class="op">)</span></code></pre></div>
<pre><code>## Call:
## ergm(formula = cranborne ~ edges + triangle + threetrail + altkstar(lambda = 2, 
##     fixed = TRUE), control = control.ergm(MCMC.burnin = 1000, 
##     MCMC.interval = 15000, MCMC.samplesize = 25000, seed = 34526))
## 
## Monte Carlo Maximum Likelihood Results:
## 
##            Estimate Std. Error MCMC % z value Pr(&gt;|z|)    
## edges      -3.74166    0.91423      0  -4.093   &lt;1e-04 ***
## triangle    1.59951    0.21921      0   7.297   &lt;1e-04 ***
## threetrail -0.04077    0.01622      0  -2.513    0.012 *  
## altkstar.2  0.59694    0.39283      0   1.520    0.129    
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
##      Null Deviance: 687.6  on 496  degrees of freedom
##  Residual Deviance: 286.0  on 492  degrees of freedom
##  
## AIC: 294  BIC: 310.8  (Smaller is better. MC Std. Err. = 0.08471)</code></pre>
<p>As our results show, we have three significant predictors: <code>edges</code>, <code>triangle</code>, and <code>threetrail</code> and <code>altkstar</code> is not significant (at <span class="math inline">\(\alpha = 0.05\)</span>) just as Brughmans and Brandes (2017) found. Looking at our coefficients, our negative <code>edges</code> term suggests that edges are more likely absent than present in our model as we would expect given the density. For <code>triangle</code> we have a positive coefficient suggesting that <code>triangles</code> are more likely than we would expect by chance. Finally, <code>threetrails</code> are slightly less common than we would expect in a random network. The difference is small but statistically significant.</p>
<p>Brughmans and Brandes (2017) generated similar results but their assessments of the goodness of fit of their model (see discussion below) caused them to create a second model with an additional term to capture the tendency for nodes to be connected to other nodes (and thus not be <code>isolates</code>).</p>
<p>Let’s run the second model and look at the results:</p>
<div class="sourceCode" id="cb580"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mod2</span> <span class="op">&lt;-</span> <span class="fu">ergm</span><span class="op">(</span>
  <span class="va">cranborne</span> <span class="op">~</span> <span class="va">edges</span> <span class="op">+</span> <span class="va">triangle</span> <span class="op">+</span> <span class="va">threetrail</span> <span class="op">+</span>
    <span class="fu">altkstar</span><span class="op">(</span><span class="fl">2</span>, fixed <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">+</span> <span class="va">isolates</span>,
  control <span class="op">=</span> <span class="fu">control.ergm</span><span class="op">(</span>
    MCMC.burnin <span class="op">=</span> <span class="fl">1000</span>,
    MCMC.interval <span class="op">=</span> <span class="fl">15000</span>,
    MCMC.samplesize <span class="op">=</span> <span class="fl">25000</span>,
    seed <span class="op">=</span> <span class="fl">1346</span>
  <span class="op">)</span>
<span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">mod2</span><span class="op">)</span></code></pre></div>
<pre><code>## Call:
## ergm(formula = cranborne ~ edges + triangle + threetrail + altkstar(2, 
##     fixed = TRUE) + isolates, control = control.ergm(MCMC.burnin = 1000, 
##     MCMC.interval = 15000, MCMC.samplesize = 25000, seed = 1346))
## 
## Monte Carlo Maximum Likelihood Results:
## 
##            Estimate Std. Error MCMC % z value Pr(&gt;|z|)    
## edges      -7.60337    2.69813      0  -2.818  0.00483 ** 
## triangle    1.62452    0.20215      0   8.036  &lt; 1e-04 ***
## threetrail -0.05946    0.02256      0  -2.635  0.00841 ** 
## altkstar.2  1.92114    0.98390      0   1.953  0.05087 .  
## isolates   -2.57763    1.61226      0  -1.599  0.10987    
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
##      Null Deviance: 687.6  on 496  degrees of freedom
##  Residual Deviance: 283.4  on 491  degrees of freedom
##  
## AIC: 293.4  BIC: 314.4  (Smaller is better. MC Std. Err. = 0.04119)</code></pre>
<p>In this model we again obtain results that mirror those of Brughmans and Brandes (2017). We see with our <code>edges</code> term a tendency for edges to be absent as we would expect. For <code>triangle</code> we see a strong tendency for closed triangles in our network as Tilley’s model predicted. We do not however see a tendency towards visual pathways beyond what we would expect by chance as our <code>threetrail</code> term suggests a slight tendency away from these configurations. With the addition of the <code>isolates</code> term our <code>altkstar</code> term is significant and positive suggesting a tendency for some nodes to have higher degree than most. Finally, <code>isolates</code> is negative suggesting a tendency against isolated nodes but the p-value is a bit higher so we should not put too much interpretive weight in this coefficient estimate.</p>
</div>
<div id="GOF" class="section level3" number="8.2.4">
<h3>
<span class="header-section-number">8.2.4</span> Assessing Goodness-of-Fit<a class="anchor" aria-label="anchor" href="#GOF"><i class="fas fa-link"></i></a>
</h3>
<p>If we compare model fit statistics we can see that the AIC for model 2 is slightly lower than for model 1. Further, the difference between the Null and residual deviance is slightly greater for model 2. At the same time, the BIC for model 2 is slightly higher than for model 1. Overall this suggests that the two models are quite similar in terms of their improvement over a model with no predictors but we don’t have strong statistical argument from these terms alone for picking one over the other (and thus it probably makes sense to evaluate fit statistics as we show here or theoretical arguments for preferring one model or the other).</p>
<p>To take this further we can use the <code>gof</code> or goodness-of-fit function in <code>ergm</code> to assess the degree to which our models provide reasonable descriptions of our observations. We can start by running the <code>gof</code> function for both models. This function provides visualizations and other statistics to help assess the degree to which model statistics, node degree, edge-wise shared partners, and geodesic distance between nodes are preserved in the networks simulated in the ERGM. If you run this function on a directed network, you additionally get assessmess of indegree and outdegree.</p>
<div class="sourceCode" id="cb582"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mod1_gof</span> <span class="op">&lt;-</span> <span class="fu">gof</span><span class="op">(</span><span class="va">mod1</span><span class="op">)</span>
<span class="va">mod2_gof</span> <span class="op">&lt;-</span> <span class="fu">gof</span><span class="op">(</span><span class="va">mod2</span><span class="op">)</span>

<span class="va">mod1_gof</span><span class="op">$</span><span class="va">summary.model</span></code></pre></div>
<pre><code>##                 obs    min     mean       max MC p-value
## edges       49.0000  32.00  49.9100   74.0000       1.00
## triangle    22.0000   5.00  24.2100  143.0000       0.80
## threetrail 628.0000 224.00 689.5200 3028.0000       0.80
## altkstar.2 102.7891  59.25 106.3128  206.5781       0.98</code></pre>
<div class="sourceCode" id="cb584"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mod2_gof</span><span class="op">$</span><span class="va">summary.model</span></code></pre></div>
<pre><code>##                 obs     min    mean       max MC p-value
## edges       49.0000  31.000  50.140   63.0000       0.86
## triangle    22.0000   5.000  22.590   76.0000       0.84
## threetrail 628.0000 226.000 654.230 1568.0000       0.98
## altkstar.2 102.7891  58.875 106.187  150.7266       0.86
## isolates     3.0000   0.000   2.780   11.0000       0.98</code></pre>
<p>The summary output for each model shows the observed feature value for a given term and then the min, max, and mean value in the simulated networks. In general, we want the mean values to match closely with relatively small ranges around them. The MC p-value (Markov Chain p-value) provides and indication of fit here where higher numbers generally indicate a better fit. This is essentially the proportion of the steps in the chain where a given term met certain criteria. In general the results here suggest that the model terms generally provide a better fit for model 2 than model 1 (as Brughmans and Brandes also suggested using somewhat different goodness-of-fit statistics not directly calculated in <code>ergm</code>).</p>
<p>It is also instructive to compare the properties of our randomly generated networks under each model to the observed network for properties that weren’t directly included in our model. The <code>gof</code> function can be plotted directly to provide this information. Let’s look at the four plots provided for both models:</p>
<div class="sourceCode" id="cb586"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span>
<span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">mod1_gof</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="07-ergm_files/figure-html/unnamed-chunk-15-1.png" width="672"></div>
<div class="sourceCode" id="cb587"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">mod2_gof</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="07-ergm_files/figure-html/unnamed-chunk-15-2.png" width="672"></div>
<p>In each of these plots the solid black line represents the values for a given property in our observed network and the boxplots represent the distribution of values obtained in our randomly generated networks. As both plots show the median model statistics are quite similar to the observed in both models. In general we want to see the observed values to fall within the densest portion of the values for our randomly generated networks (i.e., near the middle of the boxplots and certainly within the range). In our example here, both the observed degree distribution and edge-wise shared partners (the number of nodes with a specific number of partners) are quite similar to the simulated range of values. Importantly, we did not include terms for degree or edge-wise shared partners in our model but it still generated networks that closely match our observed in terms of these properties. This is evidence of a good fit. For minimum geodesic distance (length of shortest paths) however, we see that both models consistently over-estimated the geodesic distance for nodes for middling values. Overall, this suggests a fairly good (but not perfect) match between our simulated and observed network properties despite these properties not be directly included in our models. Importantly, our interpretation of our network doesn’t hinge on geodesic distance so this mismatch is not a huge problem. No model is perfect but these results suggest that that model we tested here at least approximates the features of our observed network most relevant to our theoretical model.</p>
</div>
<div id="Diagnostics" class="section level3" number="8.2.5">
<h3>
<span class="header-section-number">8.2.5</span> Assessing Models and MCMC Diagnostics<a class="anchor" aria-label="anchor" href="#Diagnostics"><i class="fas fa-link"></i></a>
</h3>
<p>Another important consideration we have not yet discussed is the need to assess the diagnostics of our model generating process to evalute if it operated as expected. The <code>ergm</code> package generates our random networks using a <a href="https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo">Markov Chain Monte Carlo (MCMC)</a> process. MCMC is a means for efficiently randomly sampling from a high-dimensional probability distribution. We want to ensure that as our MCMC process explores the parameter space fully and that it does not generate problematic data such as temporally correlated estimates or highly skewed distributions of coefficient estimates. Problems like these would be an indication of poor model specification (the inappropriate inclusion or exclusion of relevant terms for predicting our network).</p>
<p>In order to assess our models, we can use the <code>mcmc.diagnostics</code> function. Here we run it for model 2 and look at the results. We also call the <code>latticeExtra</code> package here as that helps make the visual output look a bit better.</p>
<div class="sourceCode" id="cb588"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="http://latticeextra.r-forge.r-project.org/">latticeExtra</a></span><span class="op">)</span>
<span class="fu">mcmc.diagnostics</span><span class="op">(</span><span class="va">mod2</span><span class="op">)</span></code></pre></div>
<pre><code>## Sample statistics summary:
## 
## Iterations = 3127500:62500000
## Thinning interval = 2500 
## Number of chains = 1 
## Sample size per chain = 23750 
## 
## 1. Empirical mean and standard deviation for each variable,
##    plus standard error of the mean:
## 
##                 Mean      SD Naive SE Time-series SE
## edges      4.961e-01   5.810  0.03770        0.03936
## triangle   1.505e+00   8.300  0.05386        0.06611
## threetrail 2.358e+01 149.343  0.96906        1.07973
## altkstar.2 1.796e+00  17.066  0.11074        0.11878
## isolates   5.895e-04   1.799  0.01167        0.01167
## 
## 2. Quantiles for each variable:
## 
##               2.5%     25%    50%    75%  97.5%
## edges       -11.00  -3.000  1.000   4.00  12.00
## triangle    -11.00  -4.000  0.000   6.00  22.00
## threetrail -232.00 -81.000 11.000 114.00 357.00
## altkstar.2  -31.01  -9.656  1.595  13.08  35.78
## isolates     -3.00  -1.000  0.000   1.00   4.00
## 
## 
## Are sample statistics significantly different from observed?
##                   edges      triangle    threetrail   altkstar.2     isolates
## diff.      4.961263e-01  1.505432e+00  2.358029e+01 1.795793e+00 0.0005894737
## test stat. 1.260538e+01  2.277319e+01  2.183906e+01 1.511878e+01 0.0505052519
## P-val.     1.972186e-36 8.456534e-115 9.875989e-106 1.217728e-51 0.9597197643
##            Overall (Chi^2)
## diff.                   NA
## test stat.    8.728784e+02
## P-val.       1.031866e-182
## 
## Sample statistics cross-correlations:
##                 edges    triangle threetrail altkstar.2    isolates
## edges       1.0000000  0.66456994  0.8629153  0.9781116 -0.54320356
## triangle    0.6645699  1.00000000  0.8495920  0.7523098 -0.05753382
## threetrail  0.8629153  0.84959205  1.0000000  0.9371681 -0.20534272
## altkstar.2  0.9781116  0.75230982  0.9371681  1.0000000 -0.38032908
## isolates   -0.5432036 -0.05753382 -0.2053427 -0.3803291  1.00000000
## 
## Sample statistics auto-correlation:
## Chain 1 
##                   edges     triangle   threetrail   altkstar.2     isolates
## Lag 0      1.0000000000 1.000000e+00  1.000000000  1.000000000  1.000000000
## Lag 2500   0.0429091833 1.923780e-01  0.095528809  0.059569304  0.004099518
## Lag 5000   0.0097481059 4.664168e-02  0.021285573  0.013925158 -0.006208182
## Lag 7500  -0.0004124377 8.484439e-03 -0.004538084 -0.003439839  0.009006027
## Lag 10000  0.0013139749 3.333200e-03  0.002856167  0.002174916  0.003930273
## Lag 12500  0.0049697502 1.209685e-05  0.006275546  0.007192035 -0.006963082
## 
## Sample statistics burn-in diagnostic (Geweke):
## Chain 1 
## 
## Fraction in 1st window = 0.1
## Fraction in 2nd window = 0.5 
## 
##      edges   triangle threetrail altkstar.2   isolates 
##    -0.3864     0.6796     0.2605    -0.1335     0.7546 
## 
## Individual P-values (lower = worse):
##      edges   triangle threetrail altkstar.2   isolates 
##  0.6991902  0.4967317  0.7944651  0.8938198  0.4504707 
## Joint P-value (lower = worse):  0.7725547 .</code></pre>
<p><img src="07-ergm_files/figure-html/unnamed-chunk-17-1.png" width="672"><img src="07-ergm_files/figure-html/unnamed-chunk-17-2.png" width="672"></p>
<pre><code>## 
## MCMC diagnostics shown here are from the last round of simulation, prior to computation of final parameter estimates. Because the final estimates are refinements of those used for this simulation run, these diagnostics may understate model performance. To directly assess the performance of the final model on in-model statistics, please use the GOF command: gof(ergmFitObject, GOF=~model).</code></pre>
<p>In this output the particularly relevant parts include:</p>
<ul>
<li>
<strong>sample statistic auto-correlation</strong> - This is a measure of the correlation between values in the MCMC chain for each term across the number of steps (lags) indicated. Ideally, we would want to see low values for all but the Lag 0 and our example here looks good in that respect.</li>
<li>
<strong>sample statistic burn-in diagnostic (Geweke)</strong> - Burn-in refers to the number of points calculated before the MCMC starts recording points that will be included in our coefficient estimates. A burn-in helps deal with “start up effects” that can sometimes appear when we have a poor initial estimate of a parameter. For the Geweke statistics we actually want to obtain p-values close to 1 which, again this example satisfies.</li>
<li>
<strong>MCMC plots</strong> - The plots presented above show two plots for each term. The plot on the left is called the trace plot and it displays every retained value in the MCMC sampling chain included in the estimate. For this plot, we want to see values with roughly even distributions above and below 0 and with no obvious trends. The second plot shows the density of estimates for each term as a simple density plot. For these we want to see roughly bell-shaped curves centered close to 0, which indicates good convergence of our model. In our example here most of our terms look good though <code>triangle</code> is slightly skewed. This is not particularly egregious but if working on this model to make a specific argument about our <code>triangle</code> term we might choose to run a much longer MCMC chain to improve our fit. For some very complex models this may take many hours so it is often a good idea to run initial models and then set up longer runs overnight or when you will not be using your computer.</li>
</ul>
<div class="rmdwarning">
<p>
In the example above we noted that all of our terms appeared to look
good in our model diagnostics though the term <code>triangle</code>
produced a slightly skewed distribution with a long-tail of randomly
generated networks that had more closed triangles than the mean and the
observed. Why might this be?
</p>
<p>
Although we are often interested in transitivity and other properties
of networks that rely on triangles, the number of closed triads in a
network is actually highly constrained on other lower-level features
already included in the model: specifically the number of nodes and
density. There is considerable experimental work that demonstrates that
the majority of the variation in triad configurations can be explained
by these two simple terms in many networks (see Faust 2007, 2008, 2010).
The inclusion of these related terms can confound the MCMC algorithm
designed to generate estimates of model parameters and sometimes lead to
the exploration of unlikely parameter combinations. This is not uncommon
for ERGM terms that include dyadic or triadic relationships. In a
section below we discuss <a href="ERGM.html#Degeneracy">model degeneracy</a>
(which refers to models that fail to converge) and what can be done
about it, including alternatives to the <code>triangle</code> model
term.
</p>
</div>
</div>
</div>
<div id="SimERGMs" class="section level2" number="8.3">
<h2>
<span class="header-section-number">8.3</span> Simulating Networks from ERGMs<a class="anchor" aria-label="anchor" href="#SimERGMs"><i class="fas fa-link"></i></a>
</h2>
<p>It is possible to generate and explore network simulated using a particular ERGM using the <code>simulate</code> function. Let’s generate some random networks from model 2 used above and then look at them along with the original network.</p>
<p>In the code below we simply run a single <code>simulate</code> function with the model object, the argument <code>nsim</code> representing the number of networks we wish to generate, and <code>seed</code> which is the random seed for reproducability. The output is a <code><a href="https://rdrr.io/r/base/list.html">list()</a></code> object containing multiple <code>network</code> format objects.</p>
<div class="sourceCode" id="cb591"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">sim_nets</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/simulate.html">simulate</a></span><span class="op">(</span><span class="va">mod2</span>, nsim <span class="op">=</span> <span class="fl">9</span>, seed <span class="op">=</span> <span class="fl">3464524</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span> <span class="co"># set up for multipanel plotting</span>
<span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">9</span><span class="op">)</span> <span class="op">{</span>
  <span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">sim_nets</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span>,
       vertex.cex <span class="op">=</span> <span class="op">(</span><span class="fu">sna</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sna/man/degree.html">degree</a></span><span class="op">(</span><span class="va">sim_nets</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">)</span> <span class="op">/</span> <span class="fl">4</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<div class="inline-figure"><img src="07-ergm_files/figure-html/unnamed-chunk-19-1.png" width="672"></div>
<div class="sourceCode" id="cb592"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="co"># return to single panel</span>
<span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">cranborne</span>,
     vertex.cex <span class="op">=</span> <span class="op">(</span><span class="fu">sna</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sna/man/degree.html">degree</a></span><span class="op">(</span><span class="va">cranborne</span><span class="op">)</span> <span class="op">/</span> <span class="fl">4</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="07-ergm_files/figure-html/unnamed-chunk-19-2.png" width="672"></div>
<p>These simulations help us better understand the model we have created. There are a obvious similarities between the original network and the simulations but there are also key differences. In particular, most of the random simulations created networks with a single large component whereas the original network has multiple components. This likely explains the mismatch in our goodness-of-fit statistics for geodesic distance. We could perhaps deal with this by including additional terms such as terms defined in relation to geographic location or clustering, but that is an experiment for another day.</p>
</div>
<div id="ERGMterms" class="section level2" number="8.4">
<h2>
<span class="header-section-number">8.4</span> Additional Info on ERGM Terms<a class="anchor" aria-label="anchor" href="#ERGMterms"><i class="fas fa-link"></i></a>
</h2>
<p>In the Cranborne Chase example above, we were working with a published example so the hard part (thinking about how a particular theory can be conceptualized in formal network model terms) was done for us. In practice, choosing terms to use can be quite difficult and confusing. This is particularly true because there are multiple terms that do essentially the same thing in different ways. In this section we first walk through a few of the other common options that were not covered above and then provide some advice on where to go next.</p>
<p>In the first example below we will be using the <a href="DataAndWorkspace.html#Cibola">Cibola technological similarity networks</a> used in several other portions of this guide. The data imported below includes a <code>network</code> object and a data frame that contains attributes relating to the nodes in that network. We load in the data and then assign attributes to the <code>Cibola_n</code> object.</p>
<p>The attributes we assign include:</p>
<ul>
<li>
<strong>region</strong> - A nominal regional designation for each node.</li>
<li>
<strong>pubarch</strong> - A nominal identification of the type of public architecture present at each settlement. Note that model terms cannot include <code>NA</code> data so empty values should include names like “none”</li>
<li>
<strong>d_mat</strong> - An edge attribute which is defined by a distance matrix among all settlements in meters.</li>
</ul>
<div class="sourceCode" id="cb593"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/load.html">load</a></span><span class="op">(</span><span class="st">"data/Cibola_n.RData"</span><span class="op">)</span>
<span class="co"># Cibola_n network object</span>
<span class="co"># Cibola_attr - attribute data frame</span>

<span class="co"># add node attribute based on region</span>
<span class="va">cibola_n</span> <span class="op"><a href="https://rdrr.io/pkg/network/man/network.extraction.html">%v%</a></span> <span class="st">"region"</span> <span class="op">&lt;-</span> <span class="va">cibola_attr</span><span class="op">$</span><span class="va">Region</span>
<span class="co"># add node attribute based on public architecture</span>
<span class="va">cibola_n</span> <span class="op"><a href="https://rdrr.io/pkg/network/man/network.extraction.html">%v%</a></span> <span class="st">"pubarch"</span> <span class="op">&lt;-</span> <span class="va">cibola_attr</span><span class="op">$</span><span class="va">Great.Kiva</span>

<span class="co"># matrix of distances among settlements</span>
<span class="va">d_mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/dist.html">dist</a></span><span class="op">(</span><span class="va">cibola_attr</span><span class="op">[</span>, <span class="fl">2</span><span class="op">:</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>In many cases we want to use attributes of nodes or edges as predictors in our ERGMs rather than simply network structures. This can be done a few different ways but in the example below we use the <code>nodematch</code> term which calculates a coefficient for nodes that share values for a given attribute. We can also set an additional argument in <code>nodematch</code> which specifies coefficient for each unique value in the node attribute (<code>diff = TRUE</code>). Finally, we use a matrix of geographic distances of edges as a <code>edgecov</code> (edge covariate) term. This term expects a square matrix of <code>n x n</code> for where <code>n</code> is the number of nodes in the network and helps us assess the degree to which the distance between settlemetns is predictive of the presence or absence of an edge.</p>
<p>Let’s take a look at an example using all three of these terms:</p>
<div class="sourceCode" id="cb594"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mod_cibola</span> <span class="op">&lt;-</span> <span class="fu">ergm</span><span class="op">(</span><span class="va">cibola_n</span> <span class="op">~</span> <span class="va">edges</span> <span class="op">+</span> <span class="fu">nodematch</span><span class="op">(</span><span class="st">"region"</span><span class="op">)</span> <span class="op">+</span>
                     <span class="fu">nodematch</span><span class="op">(</span><span class="st">"pubarch"</span>, diff <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">+</span>
                     <span class="fu">edgecov</span><span class="op">(</span><span class="va">d_mat</span><span class="op">)</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">mod_cibola</span><span class="op">)</span></code></pre></div>
<pre><code>## Call:
## ergm(formula = cibola_n ~ edges + nodematch("region") + nodematch("pubarch", 
##     diff = TRUE) + edgecov(d_mat))
## 
## Maximum Likelihood Results:
## 
##                                            Estimate Std. Error MCMC % z value
## edges                                     1.196e+00  3.513e-01      0   3.405
## nodematch.region                          1.299e+00  4.593e-01      0   2.828
## nodematch.pubarch.Cicular Great Kiva      2.843e-01  4.439e-01      0   0.640
## nodematch.pubarch.none                   -7.750e-01  2.763e-01      0  -2.805
## nodematch.pubarch.Rectangular Great Kiva -6.913e-01  5.448e-01      0  -1.269
## edgecov.d_mat                            -2.323e-05  3.847e-06      0  -6.039
##                                          Pr(&gt;|z|)    
## edges                                    0.000662 ***
## nodematch.region                         0.004688 ** 
## nodematch.pubarch.Cicular Great Kiva     0.521864    
## nodematch.pubarch.none                   0.005026 ** 
## nodematch.pubarch.Rectangular Great Kiva 0.204441    
## edgecov.d_mat                             &lt; 1e-04 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
##      Null Deviance: 644.6  on 465  degrees of freedom
##  Residual Deviance: 489.2  on 459  degrees of freedom
##  
## AIC: 501.2  BIC: 526.1  (Smaller is better. MC Std. Err. = 0)</code></pre>
<p>This creates output just like our example above and this gives you a sense of how categorical and covariate ERGM terms work. In this example we have a positive coefficient for <code>edges</code> suggesting that there more edges are active than are not. Further, we have a positive coefficient for <code>nodematch.region</code> indicating that there are more edges between pairs of sites in the same region than would be expected by chance. If we skip down to <code>edgecov.d_mat</code> we can see the impact of distance on edges. We have a negative coefficient (which is very close to zero: <code>-2.323e-05</code>)which suggests that there are slight more longer distance connections than shorter ones in this network (because although there is a tendency for connections within regions there are also many connections between regions). Finally, we have the <code>nodematch.pubarch</code> variables for each value in <code>pubarch</code>. The only term that is statistically significant here is <code>nodematch.pubarch.none</code> which is negative suggesting that sites without public architecture have fewer connections than we would expect by chance.</p>
<p>The examples above basically cover all of the common applications of <code>ergm</code> terms. There are terms that are specific to directed networks, weighted networks, bipartite networks, and even multilayers networks but the basic procedures of using them are covered in the examples above. Everything else is finding the right model to fit your data (and this really is the hard part). There is no magic bullet here but in general we suggest you carefully read the <a href="https://zalmquist.github.io/ERGM_Lab/ergm-terms.html#:~:text=ergm%20functions%20such%20as%20ergm,valued%20mode%20and%20vice%20versa.">ERGM term descriptions</a> and consider how these different terms relate to your data and network theories. Your efforts will be better spent when your model is designed in relation to a specific and well-described network theory/hypothesis. We suggest reading the archaeological examples of ERGMs cited in this document and in the broader networks literature to get a sense of what is possible before diving into your own ERGM project.</p>
<div id="Degeneracy" class="section level3" number="8.4.1">
<h3>
<span class="header-section-number">8.4.1</span> Avoiding Model Degeneracy<a class="anchor" aria-label="anchor" href="#Degeneracy"><i class="fas fa-link"></i></a>
</h3>
<p>Model degeneracy refers to when a specified ERGM never converges. What this means is there is some term or combination of terms in the model that have created a situation where no networks with the given properties can be obtained (or can only be obtained in very rare combinations of circumstances). What this typically looks like when this happens in R is that you enter your <code>ergm</code> call at the command line and things appear to be going okay but then you eventually get hung up with something like “Estimating equations are not within tolerance region. Iteration 2 of at most 60” and nothing happens for a long time.</p>
<p>As described above in our assessment of MCMC diagnostics, this can sometimes happen because you have specified a term that essentially does not allow for for simulated networks that approximate the observed. A classic example is a network with terms for <code>edges</code> and <code>triangle</code> for triadic closure and no other terms.</p>
<p>If you were to run a model using our Cranborne data using on the <code>edges</code> and <code>triangle</code> term, it would never converge despite the fact that the <code>triangle</code> term was included in the successful model above. As this suggests, poorly specified models are not just about the presence or absence of a single term but about the combination of terms used.</p>
<div class="rmdwarning">
<p>
Do not run the chunk of code below. We promise, it doesn’t go
anywhere and will just waste your time.
</p>
</div>
<div class="sourceCode" id="cb596"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mod_fail</span> <span class="op">&lt;-</span> <span class="fu">ergm</span><span class="op">(</span><span class="va">cranborne</span> <span class="op">~</span> <span class="va">edges</span> <span class="op">+</span> <span class="va">triangle</span><span class="op">)</span></code></pre></div>
<p>What then, can we do in the place of including terms that cause model degeneracy? Luckily there are a number of additional terms that have been designed to deal with exactly this issue. These include the “geometrically weighted” terms that are already built right into the <code>ergm</code> package. For example, the term <code>gwesp</code> or geometrically weighted shared partners is a measure of triadic closure that doesn’t rely on the specific count of triangles, but instead on the tendency towards closing individual triads in the network.</p>
<p>Let’s try our model again substituting the <code>gwesp</code> term in the place of <code>triangle</code>.</p>
<div class="sourceCode" id="cb597"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mod_win</span> <span class="op">&lt;-</span> <span class="fu">ergm</span><span class="op">(</span><span class="va">cranborne</span> <span class="op">~</span> <span class="va">edges</span> <span class="op">+</span> <span class="fu">gwesp</span><span class="op">(</span><span class="fl">0.25</span>, fixed <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,
                control <span class="op">=</span> <span class="fu">control.ergm</span><span class="op">(</span>seed <span class="op">=</span> <span class="fl">2362</span><span class="op">)</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">mod_win</span><span class="op">)</span></code></pre></div>
<pre><code>## Call:
## ergm(formula = cranborne ~ edges + gwesp(0.25, fixed = TRUE), 
##     control = control.ergm(seed = 2362))
## 
## Monte Carlo Maximum Likelihood Results:
## 
##                  Estimate Std. Error MCMC % z value Pr(&gt;|z|)    
## edges             -3.4856     0.3307      0 -10.539   &lt;1e-04 ***
## gwesp.fixed.0.25   1.1627     0.2596      0   4.479   &lt;1e-04 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
##      Null Deviance: 687.6  on 496  degrees of freedom
##  Residual Deviance: 289.1  on 494  degrees of freedom
##  
## AIC: 293.1  BIC: 301.5  (Smaller is better. MC Std. Err. = 0.2945)</code></pre>
<p>So the model converges and we get <code>gwesp</code> as a statistically significant predictor with a positive coefficient estimate just as we saw with <code>triangle</code> in the complete model. Indeed if we include <code>gwesp</code> in the complete model we get results that largely mirror those above suggesting that this term is playing a similar role.</p>
<div class="sourceCode" id="cb599"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mod_win2</span> <span class="op">&lt;-</span>
  <span class="fu">ergm</span><span class="op">(</span>
    <span class="va">cranborne</span> <span class="op">~</span> <span class="va">edges</span> <span class="op">+</span> <span class="fu">gwesp</span><span class="op">(</span><span class="fl">0.25</span>, fixed <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">+</span> <span class="va">threetrail</span> <span class="op">+</span>
      <span class="fu">altkstar</span><span class="op">(</span><span class="fl">2</span>, fixed <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">+</span> <span class="va">isolates</span>,
    control <span class="op">=</span> <span class="fu">control.ergm</span><span class="op">(</span>seed <span class="op">=</span> <span class="fl">1346</span><span class="op">)</span>
  <span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">mod_win2</span><span class="op">)</span></code></pre></div>
<pre><code>## Call:
## ergm(formula = cranborne ~ edges + gwesp(0.25, fixed = TRUE) + 
##     threetrail + altkstar(2, fixed = TRUE) + isolates, control = control.ergm(seed = 1346))
## 
## Monte Carlo Maximum Likelihood Results:
## 
##                  Estimate Std. Error MCMC % z value Pr(&gt;|z|)    
## edges            -9.04117    3.36219      0  -2.689  0.00717 ** 
## gwesp.fixed.0.25  1.51929    0.36396      0   4.174  &lt; 1e-04 ***
## threetrail       -0.03945    0.02866      0  -1.376  0.16874    
## altkstar.2        1.91799    1.22533      0   1.565  0.11752    
## isolates         -3.58093    1.88523      0  -1.899  0.05750 .  
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
##      Null Deviance: 687.6  on 496  degrees of freedom
##  Residual Deviance: 284.6  on 491  degrees of freedom
##  
## AIC: 294.6  BIC: 315.6  (Smaller is better. MC Std. Err. = 0.4782)</code></pre>
<p>What about the numbers we’re providing to the <code>gwesp</code> term argument <code>(0.25, fixed = TRUE)</code>. These number specify the so-called decay parameter in the model and whether or not that parameter should be fixed or allowed to vary across steps in the MCMC process. The details of this are well beyond the scope of this tutorial but suffice it to say that the general advice is to select the decay value that produces the best fit model in your given analysis. If you run your model without <code>fixed = TRUE</code> the model will attempt to estimate the decay parameter and you will get an additional result in our output the specifies the coefficient for that decay term as well. Keep in mind that this is essentially adding a term to the model so it may then be harder or take longer to fit your models.</p>
<p>Here is an example:</p>
<div class="sourceCode" id="cb601"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mod_nofix</span> <span class="op">&lt;-</span> <span class="fu">ergm</span><span class="op">(</span><span class="va">cranborne</span> <span class="op">~</span> <span class="va">edges</span> <span class="op">+</span> <span class="va">gwesp</span>,
                  control <span class="op">=</span> <span class="fu">control.ergm</span><span class="op">(</span>seed <span class="op">=</span> <span class="fl">23642</span><span class="op">)</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">mod_nofix</span><span class="op">)</span></code></pre></div>
<pre><code>## Call:
## ergm(formula = cranborne ~ edges + gwesp, control = control.ergm(seed = 23642))
## 
## Monte Carlo Maximum Likelihood Results:
## 
##             Estimate Std. Error MCMC % z value Pr(&gt;|z|)    
## edges        -3.3989     0.3120      0 -10.892  &lt; 1e-04 ***
## gwesp         0.9357     0.2915      0   3.210  0.00133 ** 
## gwesp.decay   0.5738     0.3125      0   1.836  0.06636 .  
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
##      Null Deviance: 687.6  on 496  degrees of freedom
##  Residual Deviance: 288.2  on 493  degrees of freedom
##  
## AIC: 294.2  BIC: 306.8  (Smaller is better. MC Std. Err. = 0.3811)</code></pre>
<p>In addition to the <code>gwesp</code> term, there are many additional terms <a href="https://zalmquist.github.io/ERGM_Lab/ergm-terms.html#:~:text=ergm%20functions%20such%20as%20ergm,valued%20mode%20and%20vice%20versa.">listed here</a> which fill similar roles and help you build models that avoid degeneracy. For more information see Hunter and Handcock (2006).</p>

</div>
</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="SpatialNetworks.html"><span class="header-section-number">7</span> Spatial Networks</a></div>
<div class="next"><a href="SpatialInteraction.html"><span class="header-section-number">9</span> Spatial Interaction Models</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="In this section"><h2>In this section</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#ERGM"><span class="header-section-number">8</span> Exponential Random Graph Models</a></li>
<li><a class="nav-link" href="#ERGMsInR"><span class="header-section-number">8.1</span> ERGMs in R</a></li>
<li>
<a class="nav-link" href="#CranborneChase"><span class="header-section-number">8.2</span> Cranborne Chase Visibility Network Example</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#NetProperties"><span class="header-section-number">8.2.1</span> Assessments of Network Properties</a></li>
<li><a class="nav-link" href="#fitting-models-with-ergm"><span class="header-section-number">8.2.2</span> Fitting Models with ergm</a></li>
<li><a class="nav-link" href="#ModelTheory"><span class="header-section-number">8.2.3</span> Building a Model Based on Theory</a></li>
<li><a class="nav-link" href="#GOF"><span class="header-section-number">8.2.4</span> Assessing Goodness-of-Fit</a></li>
<li><a class="nav-link" href="#Diagnostics"><span class="header-section-number">8.2.5</span> Assessing Models and MCMC Diagnostics</a></li>
</ul>
</li>
<li><a class="nav-link" href="#SimERGMs"><span class="header-section-number">8.3</span> Simulating Networks from ERGMs</a></li>
<li>
<a class="nav-link" href="#ERGMterms"><span class="header-section-number">8.4</span> Additional Info on ERGM Terms</a><ul class="nav navbar-nav"><li><a class="nav-link" href="#Degeneracy"><span class="header-section-number">8.4.1</span> Avoiding Model Degeneracy</a></li></ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/mpeeples2008/ArchNetSci/blob/main/07-ergm.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/mpeeples2008/ArchNetSci/edit/main/07-ergm.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Online Companion to <em>Archaeological Network Science</em></strong>" was written by Matthew A. Peeples and Tom Brughmans. It was last built on 2022-06-21.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
